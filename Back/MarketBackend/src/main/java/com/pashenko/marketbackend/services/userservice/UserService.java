package com.pashenko.marketbackend.services.userservice;


import com.pashenko.marketbackend.dto.AbstractDto;
import com.pashenko.marketbackend.dto.UserDto;
import com.pashenko.marketbackend.entities.userdata.Role;
import com.pashenko.marketbackend.entities.userdata.SignupToken;
import com.pashenko.marketbackend.entities.userdata.User;

import com.pashenko.marketbackend.repositories.RolesRepository;
import com.pashenko.marketbackend.repositories.UsersRepository;
import com.pashenko.marketbackend.services.AbstractService;
import jakarta.persistence.EntityExistsException;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;

@Service
public class UserService extends AbstractService<User> implements UserDetailsService {
    private final RolesRepository rolesRepository;
    private final SignupTokenService tokenService;

    public UserService(JpaRepository<User, Long> repository, RolesRepository rolesRepository, SignupTokenService tokenService) {
        super(repository);
        this.rolesRepository = rolesRepository;
        this.tokenService = tokenService;
    }

    /**
     * Saving newly registered user with activation token.
     * New user is disabled and doesn't contain any role.
     * @param entity User entity generated by EntityFactory
     * @return Saved user entity with token
     */
    @Override
    @Transactional
    public User save(User entity) {
        if(((UsersRepository)repository).existsUserByUsername(entity.getUsername())){
            throw new EntityExistsException("Given username is already exists.");
        }
        entity.setEnabled(false);
        User saved = super.save(entity);
        saved.setSignupToken(getSignupToken(saved));
        return super.update(saved);
    }

    @Override
    public <D extends AbstractDto> User update(D dto) {
        UserDto d = (UserDto) dto;
        return null;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return ((UsersRepository)repository).findByUsername(username);
    }

    private SignupToken getSignupToken(User user){
        return SignupToken.builder()
                .user(user)
                .tokenString(UUID.randomUUID().toString())
                .build();
    }

    /**
     * Activates user account.
     * Assigns default "USER" role, sets user enabled, deletes activation token
     * @param token Activation token assigned due registration.
     * @return User entity
     */
    @Transactional
    public User activateUserAccount(String token) {
        User user = ((UsersRepository)repository).findBySignupToken_TokenString(token);
        Long tokenId = user.getSignupToken().getId();
        Set<Role> roles = rolesRepository.getRolesByRole("ROLE_USER");
        user.setEnabled(true);
        user.setRoles(roles);
        user.setSignupToken(null);
        User activated = super.update(user);
        tokenService.deleteTokenById(tokenId);
        return activated;
    }

    /**
     * Wipes unactivated user`s accounts with expired activation tokens
     * Runs by scheduler
     * @param olderThan Past timestamp
     */
    public void wipeUnactivated(LocalDateTime olderThan) {
        List<SignupToken> tokens = tokenService.findTokensOlderThan(olderThan);
        repository.deleteAll(tokens.stream().map(SignupToken::getUser).toList());
    }
}
